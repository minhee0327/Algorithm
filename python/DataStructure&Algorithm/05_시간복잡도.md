# 알고리즘 복잡도 표현방법

## 1. 알고리즘 복잡도 계산이 필요한 이유

### 하나의 문제를 푸는 알고리즘은 다양할 수 있음.

- 정수의 절대값 구하기

  - 1, -1 =>> 1

  - 방법 1: 정수값을 제곱한 다음에 한해 다시 루트를 씌우기

  - 방법 2: 정수가 음수인지 확인해서 음수일 때만, -1을 곱하기

    > 다양한 알고리즘 중 어느 알고리즘이 더 좋은지 분석하기 위해 복잡도 정의하고 계산함.

## 2. 알고리즘 복잡도 계산항목

**1. 시간복잡도:** 알고리즘 실행 **속도**
**2. 공간복잡도:** 알고리즘이 사용하는 **메모리 사이즈**

> 가장 중요한 시간 복잡도를 꼭 이해하고 계산할 수 있어야 함.

### 알고리즘 시간 복잡도의 주요 요소

- 입력의 크기가 커지면 커질수록, 반복문이 알고리즘 수행 시간을 지배함

  > 반복문이 지배

### 알고리즘 성능 표기법

- Big O (빅 - 오) 표기법: O(N)
  - 알고리즘 최악의 실행시간을 표기
  - 가장 많이 /일반적으로 사용함
  - 아무리 최악의 상황이라도, 이정도의 성능은 보장한다는 의미 이기 때문
- 오메가 표기법:
  - 알고리즘 최상의 실행시간 표기
- 세타 표기법
  - 알고리즘 평균실행시간 표기

> 시간 복잡도 계산의 핵심요소는 **반복문**
> 계산표기는 최상, 평균, 최악 중 **최악의 시간인 Big-O 표기법 중심**으로 익히자

### 알고리즘1: 1부터 n까지의 합을 구하는 알고리즘1

- 합을 기록할 변수를 만들고 0을 저장
- n을 부터 1씩 증가하면서 반복
- 반복문 안에서 합을 기록할 변수에 1씩 증가된 값을 더함
- 반복이 끝나면 합을 출력
- 반복을 한번 진행하므로 O(n)

In [1]:

```
def sum_all(n):
    total = 0
    for i in range(1, n+1):
        total+=i
    return total
```

In [3]:

```
sum_all(10)
```

Out[3]:

```
55
```

### 알고리즘2: 1부터 n까지의 합을 구하는 알고리즘2

- n(n+1)/2
- 반복을 진행하지 않기때문에, O(1)

In [4]:

```
def sum_all(n):
    return int(n*(n+1)/2)
```

In [5]:

```
sum_all(10)
```

Out[5]:

```
55
```

